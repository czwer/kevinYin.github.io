---
layout: post
title:  "JVM调优实践 后篇"
date:   2016-03-20 18:16
categories: JVM
permalink: /Priest/JVM-tuning-final

---


**前言：**前两篇把调优的目的以及可用于JDK定位、分析的工具，那么本次我们将制造一个场景来进行模拟线上操作，我们厂目前JVM暂时没遇到过JVM调优问题，所以只能模拟线上环境情况来测试优化过程。

<h2>场景</h2>
模拟一个请求调用的一个方法，不断地制造大量的对象存在一个map里，让触发full  GC，导致系统访问比较卡顿。

  ```java
 private static ConcurrentHashMap<String,byte[]> bigMap = new ConcurrentHashMap<>();

    @RequestMapping("gc")
    public  void testGC(HttpServletRequest request) {
        byte[] bytes = new byte[1024 * 1024 * 3];
        while (true) {
            bigMap.put(String.valueOf(Math.random()),bytes);
        }
    }
```
-----

##分析
遇到线上卡顿状态后，不是马上dump一个文件进行分析，因为jmap dump 会导致中断JVM（jmap dump 后会触发 full GC）。如果是线上，可以按照以下顺序进行：

1.先获取进程号，使用jps获取tomcat的进程号。

>kevinYin.github.io git:master # jps

>44421 Launcher

>44422 Bootstrap

2.用` jstat -gcutil 42801 1000 20` 查看下 GC次数以及当前各区空间使用情况，以及时间长度
> S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT

> 0.00 100.00 100.00 100.00  96.54  92.50     50    2.413    12    7.188    9.602

>  0.00 100.00 100.00 100.00  96.54  92.50     50    2.413    13   10.299   12.712

触发full GC的次数12次，耗时7.188秒，
